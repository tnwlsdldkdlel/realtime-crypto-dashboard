# 제품 요구사항 정의서 (PRD)

## 1. 개요

| 항목 | 상세 내용 |
| :--- | :--- |
| **제품명** | 실시간 암호화폐 대시보드 (RCD) |
| **대상 사용자** | 암호화폐 투자자, 프론트엔드 포트폴리오 목적 |
| **목표** | Next.js의 서버 환경을 활용하여 실시간 데이터 처리, SSR/SSG 성능 최적화, 그리고 강건한 아키텍처를 입증하는 고성능 웹 애플리케이션 구축. |

---

## 2. 기술 스택 (Tech Stack) 🛠️

이 프로젝트는 고성능과 유지보수성을 강조하기 위해 다음과 같은 기술 스택을 사용합니다.

| 분류 | 기술 스택 | 사용 이유 및 역할 |
| :--- | :--- | :--- |
| **프레임워크** | **Next.js** | **SSR/SSG**를 통한 초기 로딩 성능 개선, 파일 기반 라우팅, **API Routes**를 통한 서버 계층 구현. |
| **프론트엔드 코어** | **React** | 선언적 UI 구성 및 컴포넌트 기반 개발. |
| **상태 관리** | **Zustand** (또는 Jotai, Recoil) | React 렌더링 외부에서 고빈도 실시간 데이터를 효율적으로 관리하고, 상태 분리 용이. |
| **데이터 처리** | **TypeScript** | 정규화된 데이터 구조 및 도메인 타입 정의를 통한 타입 안정성 및 코드 품질 확보. |
| **데이터 시각화** | **Lightweight Charting Library** | 과거 및 실시간 캔들스틱 데이터 시각화. |
| **성능 최적화** | **TanStack Virtual** | 수백 개의 코인 목록을 효율적으로 렌더링하기 위한 목록 가상화(Virtualization). |
| **스타일링** | **CSS Modules / Styled Components** | 컴포넌트 기반의 스타일링 및 디자인 시스템 구축 용이성. |

---

## 3. 기술 아키텍처 및 데이터 전략

### 3.1. API 전략 (Next.js 서버 활용 하이브리드 접근)

애플리케이션은 Next.js의 서버 환경을 **REST API 프록시**로 사용하여 보안과 성능을 동시에 확보합니다.

| 구성 요소 | API 유형 | 처리 위치 | 주요 사용 사례 |
| :--- | :--- | :--- | :--- |
| **Binance API** | **WebSocket** | 클라이언트 (직접 연결) | 실시간 가격, 24시간 변동률 업데이트. |
| **Binance API** | **REST** | **Next.js API Routes** | 초기 코인 목록, 과거 OHLCV 데이터 페치. |
| **핵심 이점** | **API Key 보안:** 민감한 REST API Key를 서버 환경에 안전하게 보관. **Rate Limit 관리:** 서버 측에서 중앙 집중식으로 제어하여 안정성 확보. |

### 3.2. 데이터 페칭 및 렌더링 전략 (Next.js 핵심)

* **초기 데이터 로딩:** 초기 코인 목록 및 필수 데이터는 Next.js의 **`getServerSideProps` 또는 Server Components**를 사용하여 서버에서 선(先) 페칭되어야 합니다.
* **하이드레이션 (Hydration):** 서버에서 렌더링된 초기 데이터는 클라이언트로 전달되어 하이드레이션되며, 그 후 WebSocket 연결이 시작되어 실시간 업데이트가 이어집니다.

### 3.3. 핵심 실시간 구독 전략

* **전략:** **단일 WebSocket 연결**에 **다중 스트림 구독** 방식을 활용합니다.
* **작동 방식:** 즐겨찾기 목록이 수정되면, WebSocket 스트림 매개변수를 재구성하고 **디바운스된 재연결/재구독**을 트리거하여 오버헤드를 최소화합니다.

### 3.4. 프론트엔드 아키텍처 (고성능 및 유지보수성)

* **상태 관리:** 외부 스토어(Zustand)를 통해 고빈도 데이터 업데이트를 React 렌더링과 분리.
* **데이터 구조:** 모든 실시간 데이터는 **정규화된 Map 구조**로 저장.

| 패턴/원칙 | 책임 | 근거 |
| :--- | :--- | :--- |
| **어댑터 패턴** | Binance 원시 데이터를 도메인 타입으로 정규화. | 외부 API 형식 변경으로부터 코드베이스를 격리. |
| **함수형 코어** | 상태 병합 및 비즈니스 로직에 순수 함수 사용. | **테스트 용이성** 및 **안정성** 극대화. |
| **리포지토리 패턴** | 상태 관리 계층(Zustand)을 `TickerRepository` 인터페이스 뒤에 추상화하여 라이브러리 비종속성 확보. |
| **배치 업데이트** | `requestAnimationFrame` 또는 스로틀링을 사용하여 고빈도 메시지 그룹화 후 상태 업데이트. | 컴포넌트 재렌더링 및 CPU 부하 감소. |

---

## 5. 기능 요구사항

### 5.1. RCD-F1: 실시간 코인 목록 표시

* **세부 사항:** 티커, 현재가, 24시간 변동률(%), 거래량, 고가/저가 표시. **목록 가상화** 구현. 정렬 및 필터링 기능 제공.

### 5.2. RCD-F2: 인터랙티브 차트 뷰

* **세부 사항:**
    * **초기 로드:** Next.js API Routes를 통해 REST 과거 OHLCV 데이터 페치.
    * **실시간 통합:** REST 과거 데이터와 라이브 WebSocket kline 스트림을 끊김 없이 병합.
    * **데이터 정합성:** `openTime`을 기준으로 갱신/추가 결정. **데이터 간격(Gap)** 발생 시 REST 호출을 통해 메우는 로직 구현.

### 5.3. RCD-F3: 즐겨찾기/관심 코인

* **세부 사항:** 영구적인 관심 코인 목록 제공. 이 목록이 WebSocket 다중 스트림 구독의 심볼 세트를 결정.

---

## 6. 강건성(Robustness) 및 UX 요구사항

### 6.1. RCD-R1: 에러 핸들링 및 폴백 (탄력성)

* **WebSocket 단절:** **지수 백오프/지터** 전략으로 자동 재연결 시도. 실패 시 **Degraded Mode** (느린 REST 폴링)로 전환.
* **REST API Rate Limit (429):**
    * Next.js API Routes 또는 중앙 클라이언트에서 `Retry-After` 헤더 감지.
    * **스로틀링**을 구현하고 캐시된 데이터를 우선 사용.
    * **UX:** 로딩 시 "요청 지연" 메시지와 수동 재시도 버튼 제공.

### 6.2. RCD-UX1: 실시간 시각적 피드백

* **시각적 계층:** **현재가** 및 **24시간 변동률**을 가장 크게 강조 (1계층).
* **변동 표시:** 하드한 깜빡임 대신, **300ms 소프트 하이라이트** 및 색상 복귀 트랜지션 적용.
* **애니메이션 스로틀링:** 시각적 변동 애니메이션의 실행 빈도를 **100ms 단위로 제한**하여 UI 안정성 확보.

---

## 7. 문서화 및 결과물

* **README.md:** 요약, Live Demo, 핵심 **기술 하이라이트** (Next.js 서버 활용, WebSocket, 아키텍처), **성능 측정치** 포함.
* **`/docs` 디렉토리:** **아키텍처, 실시간 전략, 성능 분석**에 대한 심층 문서화.
* **라이브 데모 페이지:** 현재 구독 중인 심볼 수, 초당 업데이트 수 등 **성능 통계**를 시각적으로 표시.